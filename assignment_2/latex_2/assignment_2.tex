\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}

\usepackage{amssymb} 
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{sansmath}
\usepackage{epsfig}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\renewcommand*\familydefault{\sfdefault}

\usepackage[margin=2cm]{geometry}

\usepackage[parfill]{parskip}
\linespread{1.2} 

\usepackage{xcolor}

\lstdefinestyle{code}{  
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{teal},
    ndkeywordstyle=\color{purple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=t,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=8pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    frame=single,
    breaklines=true
}

\lstset{style=code}

\newcounter{question}
\setcounter{question}{0}
\newcounter{subquest}

\newcommand{\question}[1]{
    \stepcounter{question} 
    \vspace{1em}
    \textbf{\Large\thequestion \ - #1}
    \vspace{.5em} 
    \setcounter{subquest}{0}\ \\}

\newcommand{\subquestion}{
    \stepcounter{subquest} 
    \vspace{.5em}
    \textbf{\large Question \thequestion.\thesubquest}
    \vspace{.25em}\ \\}

\newcommand{\solution}
    {\par\vspace{0.5em}\noindent\emph{Solution.}\ }
    {\par\vspace{1em}}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\pagestyle{fancy} 
\lhead{Math 5334: \emph{Numerical Analysis}}
\rhead{Serena Su}
\cfoot{}
\rfoot{\thepage}

\begin{document}

\begin{center}
\textbf{\huge Assignment 2}

{\large\emph{Due Date: September 22, 2025}}
\vspace{1em}
\end{center}
\hrule

\question{Lagrange Interpolation and Error Analysis}
Let $f \in C^{n+1}[a,\,b]$, and let $P_n$ be its Lagrange interpolating polynomial at the distinct nodes $x_0, x_1, \dots, x_n \in [a,\,b]$. The interpolation error is: 
\[R_n(x) = f(x) - P_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{i=0}^{n}(x - x_i),\quad \xi \in (a,\,b)\]
Suppose $f(x) = e^x$ on the interval $[0,\,1]$, for equally spaced nodes $x_i = \frac{i}{n}$.

\subquestion
Derive an explicit bound for the maximum error $\max_{x \in [0,1]} |R_n(x)|$.


\begin{proof}
    To bound $|R_n(x)|$, we start with the error formula:
    \[|R_n(x)| = \left|\frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{i=0}^{n}(x - x_i)\right|, \quad \xi \in (0,1)\]
    
    Note $\frac{1}{(n-1)!}$ is a constant. We can bound $R_n(x)$ by bounding $f^{(n+1)}(\xi)$ and $\left|\prod_{i=0}^{n}(x - x_i)\right|$ separately.
    
    Now notice that $f^{(n+1)}(x) = f(x) = e^x$ for all $n$. Since $e^x$ is strictly increasing on $[0,1]$, we have that \[f^{(n+1)}(\xi) = \max_{x \in [0,1]} |f^{(n+1)}(x)| = f(1) = e \label{f}\tag{1}\]

    Next, we need to bound $\left|\prod_{i=0}^{n}(x - x_i)\right|$. Let $\omega_{n}(x) = \prod_{i=0}^{n}(x - x_i)$. Note that $\omega_{n}(x)$ is a polynomial of degree $n+1$. Since $\omega_{n}(x)$ is continuous on the compact interval $[0,1]$, it attains its maximum at some point in $[0,1]$. We may write that: 
    \[|\omega_{n}(x)| \leq W_n \label{h}\tag{2}\]
    Where $W_n = \max_{x \in [0,1]} |\omega_{n}(x)| = |\omega_{n}(x^*)|$ for some $x^* \in [0,1]$.

    Now, we can use \eqref{f} and \eqref{h} to bound $|R_n(x)|$ from above:
    \[|R_n(x)| \leq \frac{e}{(n+1)!} W_n\]
    Since $R_n(x)$ is continuous on the compact interval $[0,1]$, $\sup_{x\in[0,1]} R_n(x) = \max_{x\in[0,1]} R_n(x)$. \\ Since the supremum is the least upper bound, we have that:
    \[\max_{x \in [0,1]} |R_n(x)| \leq \frac{e}{(n+1)!} W_n\]
    Which gives us an explicit bound for the remainder.
\end{proof}

\subquestion
Show the asymptotic decay of this error as $n \to \infty$.

\begin{proof}
    From the previous part, we have that:
    \[\max_{x \in [0,1]} |R_n(x)| \leq \frac{e}{(n+1)!} W_n\]

    Let us first make a more crude estimate of $W_n$. Note that for any $x \in [0,1]$ and for each $i$, we have:
    \[|x - x_i| \leq 1\]
    Since there are $n+1$ terms in the product, we can write:
    \[|\omega_{n}(x)| = \left|\prod_{i=0}^{n}(x - x_i)\right| \leq 1^{n+1} = 1\]
    Therefore, we get the crude bound:
    \[W_n = \max_{x \in [0,1]} |\omega_{n}(x)| \leq 1\] 
    Plugging this into our error bound, we get:
    \[\max_{x \in [0,1]} |R_n(x)| \leq \frac{e}{(n+1)!}\]
    Taking a limit as $n \to \infty$, we have:
    \[\lim_{n \to \infty} \max_{x \in [0,1]} |R_n(x)| \leq \lim_{n \to \infty} \frac{e}{(n+1)!} = 0\]
    Therefore, we have shown that the error decays to $0$ as $n \to \infty$.
\end{proof}

\newpage
\question{Interpolation Programming Exercise}
Consider the fuction:
\[f(x) = \frac{1}{1+20x}, \quad x \in[-1,1]\]

\subquestion
Construct the interpolation polynomial $P_n(x)$ at equidistant nodes for $n=5$.

\solution The following methods were used to compute this polynomial:

\begin{lstlisting}[language=Python, caption=2.1 Python]
import numpy as np

def f(x):
    return 1 / (1 + 20 * x**2)

def lagrange_coefficients(nodes):
    x = nodes
    num_nodes = len(nodes)
    # Add zeroth divided differences
    dd_table = np.array([[f(xi) for xi in nodes]])

    # Calculate divided difference table
    for i in range(1, num_nodes):
        ith_dd = np.zeros(num_nodes)

        for j in range(num_nodes - i):
            # Calculate ith divided differences
            ith_dd[j] = (dd_table[i - 1, j + 1] - dd_table[i - 1, j]) / (
                x[j + i] - x[j]
            )

        # Append the ith divided difference row to the table
        dd_table = np.vstack([dd_table, ith_dd])

    # Extract coefficients (first column of the table)
    a = np.array([dd_table[i, 0] for i in range(dd_table.shape[0])])
    return a

def generate_lagrange(nodes, degree):
    # Get coefficients
    a = lagrange_coefficients(nodes)
    # Start with function and constant term
    equation = f"P_{{{degree}}}(x) = {a[0]}"
    w = []
    # Build (x - xi) terms
    for xi in nodes:
        if abs(xi) <= 1e-14:
            w.append(f'({xi})')
        elif xi < 0:
            w.append(f"(x + {abs(xi)})")
        else:
            w.append(f"(x - {xi})")
    b = ""

    # Build polynomial string
    for i in range(1, len(a)):
        for j in range(i):
            # Multiply (x - xi) terms
            b += w[j]
        # Multiply (x - xi) product with current coefficient and add term
        if a[i] >= 0:
            equation += f" + {a[i]}{b}"
        else:
            equation += f" - {abs(a[i])}{b}"
        b = ""

    return equation

# Sample Execution
if __name__ == "__main__":
    # Generate 6 nodes for 5th degree polynomial
    nodes = np.linspace(-1, 1, 6)
    equation = generate_equation(nodes, 5)
    with open("./plots_2/q2_2/lagrange_equations.txt", "w") as file:
        file.write(equation + "\n")

\end{lstlisting}

The interpolation polynomial $P_5(x)$ at equidistant nodes for $n=5$ is given by:
\begin{align*}
    P_{5}(x) = \ & 0.047619047619047616 \\
        &+ 0.18583042973286878(x + 1.0) \\
        &+ 1.1227255129694158(x + 1.0)(x + 0.6) \\
        &- 2.0647825525874324(x + 1.0)(x + 0.6)(x + 0.19999999999999996) \\
        &+ 1.2904890953671473(x + 1.0)(x + 0.6)(x + 0.19999999999999996)\\
        &(x - 0.20000000000000018) \\
        &- 3.552713678800501e-15(x + 1.0)(x + 0.6)(x + 0.19999999999999996)\\
        &(x - 0.20000000000000018)(x - 0.6000000000000001)
\end{align*}

\newpage
\subquestion
Plot $f(x)$ and $P_n(x)$, and report the behavior of the interpolation error as $n$ increases from $5$ to $10$ and $20$.

\solution 
In addition to the functions defined in the previous part, the following functions were used to help plot $f(x)$ and $P_n(x)$:

\begin{lstlisting}[language=Python, caption=2.2 Python]
import numpy as np
import matplotlib.pyplot as plt
# I created a Figure class for figure management.
# See figure.py at end of this pdf for implementation.
from figure import Figure

def calculate_lagrange(nodes, a, x):
    # Start with constant term
    y = a[0]
    # Build (x - xi) terms
    w = [(x - xi) for xi in nodes]
    # Temporary variable to hold (x - xi) product
    b = 1

    for i in range(1, len(a)):
        for j in range(i):
            # Multiply (x - xi) terms
            b *= w[j]
        # Multiply (x - xi) product with current coefficient
        y += a[i] * b
        b = 1

    return y

def calculate_lagrange_output(nodes, x_coords=[]):
    # Get coefficients
    a = lagrange_coefficients(nodes)
    # If no x_coords provided, use nodes as x_coords
    if len(x_coords) == 0:
        x_coords = nodes
    # Calculate y coordinates for each x coordinate
    y_coordinates = np.array([calculate_lagrange(nodes, a, x) for x in x_coords])

    return y_coordinates

# Sample Execution
if __name__ == "__main__":
    fig_f.title =  "Equidistant Lagrange Interpolation"
    x = np.linspace(-1, 1, 100)
    f_x = f(x)
    nodes_x = np.linspace(-1, 1, 6)
    nodes_y = calculate_lagrange_output(nodes_x)
    p_5 = calculate_lagrange_output(nodes_x, x)

    # Figure attributes: 
    # x_sets, y_sets, labels, colors(indexes from default rotation list), 
    # markers, linestyles, title, xlabel, ylabel
    # single or multiple axes can be added during initialization
    fig_f = Figure(x, f_x, r"$f(x)$")
    fig_p5 = Figure(x, p_5, r"$P_5(x)$", 1)
    fig_nodes = Figure(nodes_x, nodes_y, "", 1, ".", "")

    # Returns a new Figure that merges fig_f, fig_p5, and fig_nodes.
    # The title of the new figure is title + " (n = 5)" 
    fig = fig_f.copy().merge([fig_p5, fig_nodes], title + " (n = 5)")

    # Returns the matplotlib figure and saves png with 300 dpi
    fig.get_figure("./plots_2/q2_2/p5.png")
    plt.show()
\end{lstlisting}

\vspace{1em}
The following plots show $f(x)$ and $P_n(x)$ for $n=5, 10, 20$:
\begin{center}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_2/p5.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_2/p10.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_2/p20.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_2/all.png}
\end{center}

As $n$ increases from $5$ to $10$ and $20$, we see that the interpolation error decreases towards the center of the interval $[-1,1]$. However, the error increases significantly near the edges of the interval, demonstrating Runge's phenomenon. 

\newpage
\subquestion
Repeat the interpolation using Chebyshev nodes, and compare the results with the equidistant-node case.

\solution
In addition to the functions defined in the previous parts, the following function was used to generate the Chebyshev nodes:
\begin{lstlisting}[language=Python, caption=2.3 Python]
import numpy as np

def chebyshev_nodes(n):
    nodes = np.array(
        [(math.cos((2 * k - 1) * math.pi / (2 * n))) for k in range(1, n + 1)]
    )

    return nodes
\end{lstlisting}

Th following plots show $f(x)$ and $P_n(x)$ for Chebyshev nodes with $n=5, 10, 20$:
\begin{center}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_3/chebyshev_p5.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_3/chebyshev_p10.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_3/chebyshev_p20.png}
    \includegraphics[width=0.8\textwidth]{../plots_2/q2_3/chebyshev_all.png}
\end{center}

Comparing these plots to those with equidistant nodes, we see that using Chebyshev nodes significantly reduces the interpolation error across the entire interval $[-1,1]$. The oscillations near the edges of the interval are much less pronounced, demonstrating that Chebyshev nodes help mitigate Runge's phenomenon and provide a more accurate approximation of $f(x)$.

\newpage
\question{Chebyshev Polynomials and Their Roots}
The Chebyshev polynomials of the first kind is defined by:
\[T_n(x) = \cos(n \arccos x), \quad x \in [-1,1]\]

\subquestion
Prove that the numbers
\[x_k = \cos\left(\frac{2k-1}{2n} \pi\right), \quad k=1,2,\dots,n\]
are the roots of $T_n(x)$.

\begin{proof}
    We want to find the values of $x$ such that $T_n(x) = 0$. By the definition of Chebyshev polynomials, we have:
    \[T_n(x) = \cos(n \arccos x)\]
    Setting $T_n(x) = 0$, we get:
    \[T_n(x) = \cos(n \arccos x) = 0\]
    The cosine function is zero at odd multiples of $\frac{\pi}{2}$.
    So $T_n(x)$ can only equal zero when $n \arccos x$ is an odd multiple of $\frac{\pi}{2}$. Therefore, we can write:
    \[n \arccos x = \frac{(2k-1)\pi}{2}, \quad k \in \mathbb{Z}\]
    Note that for $n=0$, $T_0(x) = \cos(0\cdot \arccos(x))=1$ which has no roots. So consider $n \geq 1$. Dividing both sides by $n$, we have:
    \[\arccos x = \frac{(2k-1)\pi}{2n}, \quad k \in \mathbb{Z}\]
    Taking the cosine of both sides, we get:
    \[x = \cos\left(\frac{(2k-1)\pi}{2n}\right), \quad k \in \mathbb{Z}\]
    Therefore, the set of x defined above are the roots of $T_n(x)$ for $n\geq 1$. Note that if we restrict $k$ to the integers $1, 2, \dots, n$, we exactly get that:
    \[x_k = \cos\left(\frac{2k-1}{2n} \pi\right), \quad k=1,2,\dots,n\]
    are the roots of $T_n(x)$.
\end{proof}

\newpage
\subquestion
Show that these roots are distinct and lie in the interval $(-1,1)$.

\begin{proof}
    To show that these roots are distinct, we need to show that for $k_1 \neq k_2$, we have $x_{k_1} \neq x_{k_2}$. Assume $k_1, k_2 \in \{1, 2, \dots, n\}$ such that $k_1 \neq k_2$ and $k_1 < k_2$. Then, assuming for fixed $n\geq 1$:
    \[x_{k_1} = \cos\left(\frac{2k_1-1}{2n} \pi\right), \quad 
    x_{k_2} = \cos\left(\frac{2k_2-1}{2n} \pi\right)\]
    Note that $\frac{2k_1-1}{2n} \pi$ and $\frac{2k_2-1}{2n} \pi$ are distinct angles in the interval $(0, \pi)$.
    Since the cosine function is strictly decreasing on the interval    $[0, \pi]$, and since $\frac{2k_1-1}{2n} \pi < \frac{2k_2-1}{2n} \pi$ are distinct, we have:
    \[x_{k_1} = \cos\left(\frac{2k_1-1}{2n} \pi\right) > \cos\left(\frac{2k_2-1}{2n} \pi\right) = x_{k_2}\]
    By the law of trichotomy, $x_{k_1} \neq x_{k_2}$. Therefore, the roots $x_k$ are distinct for $k=1, 2, \dots, n$.

    Next, we need to show that these roots lie in the interval $(-1,1)$. Note that from above, we have shown that ${x_k}$ is a strictly decreasing sequence. Therefore, we only need to show that the largest root $x_1$ is less than $1$ and the smallest root $x_n$ is greater than $-1$.

    First, let us show that $x_1 < 1$:
    \[x_1 = \cos\left(\frac{2(1)-1}{2n} \pi\right) = \cos\left(\frac{\pi}{2n}\right)\]
    Note that $\frac{\pi}{2n} \in (0, \frac{\pi}{2}]$. In this interval, the range of the cosine function is $[0,1)$. Therefore, we have:
    \[x_1 = \cos\left(\frac{\pi}{2n}\right) < 1 \label{x1}\tag{1}\]   
    Next, let us show that $x_n > -1$:
    \[x_n = \cos\left(\frac{2n-1}{2n} \pi\right) = \cos\left(\pi - \frac{\pi}{2n}\right)\]
    Note that $\pi - \frac{\pi}{2n} \in [\frac{\pi}{2}, \pi)$. In this interval, the range of the cosine function is $(-1, 0]$. Therefore, we have:
    \[x_n = \cos\left(\pi - \frac{\pi}{2n}\right) > -1 \label{xn}\tag{2}\]
    Combining \eqref{x1} and \eqref{xn}, we have shown that:
    \[-1 < x_n < x_k < x_1 < 1\]
    Therefore, $x_k$ are distinct roots that lie in the interval $(-1,1)$ for $k=1, 2, \dots, n$.
\end{proof}

\newpage
\subquestion
Write your own code to generate $T_n(x)$ using the recursion formula.

\solution The following code was used to generate the Chebyshev polynomials::
\begin{lstlisting}[language=Python, caption=3.3 Python]
import sympy as smp

def chebyshev_poly(n):
    # Base Cases
    if n == 0:
        return 1
    elif n == 1:
        return smp.symbols("x")
    # Recursive Case
    else:
        return 2 * smp.symbols('x') * chebyshev_poly(n - 1) - chebyshev_poly(n - 2)

def generate_chebyshev(n):
    x = smp.symbols('x')
    poly = smp.expand(chebyshev_poly(n))
    function = f"T_{{{n}}}({x})"
    equation = function + " = " + smp.latex(poly) 
    return equation

# Sample Execution
if __name__ == "__main__":
with open("./plots_2/q3_3/chebyshev_polynomials.txt", "w") as file:
    for n in range(6):
        equation = generate_chebyshev(n)
        file.write(equation + "\n")
\end{lstlisting}

The Chebyshev polynomials $T_n(x)$ for $n=0, 1, \dots, 5$ are given by:
\begin{align*}
    T_{0}(x) &= 1 \\
    T_{1}(x) &= x \\
    T_{2}(x) &= 2 x^{2} - 1 \\
    T_{3}(x) &= 4 x^{3} - 3 x \\
    T_{4}(x) &= 8 x^{4} - 8 x^{2} + 1 \\
    T_{5}(x) &= 16 x^{5 }- 20 x^{3} + 5 x \\
\end{align*}

\newpage
\question{Lagrange Interpolation for Nonsmooth Function}
Let $f(x) = |x|$ on the interval $[-1,1]$.

\subquestion
Construct the interpolation polynomial $P_n(x)$ for equidistant nodes when $n$ is even.

\subquestion
Show that $P_n(x)$ is an even polynomial.

\subquestion
Investigate analytically (for small $n$) how well $P_n(x)$ approximates $f(x)$.

\subquestion
Discuss why convergence may be slower for nonsmooth functions.

\end{document}